#include "assembler.h"
#include "helpers.h"

#include <cstdlib>
#include <iostream>
#include <format>
#include <filesystem>
#include <fstream>
#include <Windows.h>

Assembler::Assembler() {
	nasm_path.resize(MAX_PATH);
	if (DWORD len = SearchPathA(nullptr, "nasm", ".exe", nasm_path.size(), nasm_path.data(),
		             nullptr); !len) {
		std::cerr << "Couldn't find nasm executable. "
		             "This REPL requires nasm to be installed\n"
		             "Error: " << getErrorMessage() << '\n';
		std::exit(1);
	} else if (len < nasm_path.length() - 1) {
		// Make sure only the actual path goes to lpCommandLine
		nasm_path.resize(len);
	}
}

bool Assembler::assembleBuffer(const std::string& buf, std::vector<std::uint8_t>& out,
	                std::string& error, bool long_mode) {
	const std::string input_filename = getTempFilePath();
	std::ofstream input_file(input_filename);

	if (long_mode) {
		const char* long_mode_directive = "[bits 64]\n";
		input_file.write(long_mode_directive, std::strlen(long_mode_directive));
	}

	input_file.write(buf.data(), buf.size());
	input_file.close(); // Ensure the buffer is flushed

	const std::string output_filename = getTempFilePath();
	std::string nasm_stderr;
	if (!assembleFileImpl(input_filename, output_filename, nasm_stderr, error)) {
		// The error was generated by successfully ran nasm
		if (error.empty()) {
			// TODO: parse the error
			error = nasm_stderr;
		}

		return false;
	}

	if (error.empty())
		error = nasm_stderr;

	if (std::filesystem::file_size(output_filename) > 0) {
		std::ifstream nasm_output(output_filename, std::fstream::in | std::ios::binary);
		nasm_output.unsetf(std::fstream::skipws);
		const std::uintmax_t size = std::filesystem::file_size(output_filename);

		out.resize(size);
		nasm_output.read(reinterpret_cast<char*>(out.data()), out.size());
	}

	return true;
}

bool Assembler::assembleFile(const std::string& filename, std::vector<std::uint8_t>& out,
	                         std::string& error) {
	const std::string output_filename = getTempFilePath();
	std::string nasm_stderr;
	if (!assembleFileImpl(filename, output_filename, nasm_stderr, error)) {
		// The error was generated by successfully invoked nasm
		if (error.empty()) {
			// TODO: parse the error (and get the lines correctly)
			error = nasm_stderr;
		}

		return false;
	}

	// bool is_warning = nasm_stderr.find(": warning: ") != std::string::npos;
	if (error.empty()) {
		// TODO: parse the error (and get the lines correctly)
		error = nasm_stderr;
	}

	if (std::filesystem::file_size(output_filename) > 0) {
		std::ifstream nasm_output(output_filename, std::fstream::in | std::ios::binary);
		nasm_output.unsetf(std::fstream::skipws);
		const std::uintmax_t size = std::filesystem::file_size(output_filename);

		out.resize(size);
		nasm_output.read(reinterpret_cast<char*>(out.data()), out.size());
	}

	return true;
}

bool Assembler::assembleFileImpl(const std::string& filename,
                                 const std::string& output_filename,
                                 std::string& output_stderr,
                                 std::string& error) {
	SECURITY_ATTRIBUTES pipe_sec_attrib;
	pipe_sec_attrib.nLength = sizeof pipe_sec_attrib;
	pipe_sec_attrib.bInheritHandle = TRUE;
	pipe_sec_attrib.lpSecurityDescriptor = NULL;
	HANDLE stderr_write, stderr_read;
	CreatePipe(&stderr_read, &stderr_write, &pipe_sec_attrib, 0);
	SetHandleInformation(stderr_read, HANDLE_FLAG_INHERIT, 0);

	STARTUPINFO si = {0};
	si.cb = sizeof si;
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdError = stderr_write;

	std::string cmdline = std::string("\"") + nasm_path + "\" \"" + filename +
	                      "\" -o \"" + output_filename + "\"";
	PROCESS_INFORMATION info;
	if (!CreateProcessA(nasm_path.c_str(), cmdline.data(), nullptr, nullptr, true, 0,
		                nullptr, nullptr, &si, &info)) {
		error = "Cannot spawn nasm";
		CloseHandle(stderr_write);
		CloseHandle(stderr_read);
		return false;
	}
	CloseHandle(info.hThread);

	DWORD result = WaitForSingleObject(info.hProcess, 5000);
	const DWORD ec = GetLastError();
	if (WAIT_TIMEOUT == result) {
		TerminateProcess(info.hProcess, 1);
		CloseHandle(info.hProcess);
		CloseHandle(stderr_write);
		CloseHandle(stderr_read);
		error = "nasm timed out";
		return false;
	}
	// WaitForSingleObject also fails when nasm exits before it gets called
	// So the fault can only be assumed if the last error isn't invalid handle
	else if (result == WAIT_FAILED && ec == 6) {
		TerminateProcess(info.hProcess, 1);
		CloseHandle(info.hProcess);
		CloseHandle(stderr_write);
		CloseHandle(stderr_read);
		error = std::format("WaitForSingleObject failed: {}", ec);
		return false;
	}

	DWORD avail;
	PeekNamedPipe(stderr_read, nullptr, 0, nullptr, &avail, nullptr);
	if (avail != 0) {
		std::string err;
		err.resize(512);
		DWORD n_read = 0;
		ReadFile(stderr_read, err.data(), err.size() - 1, &n_read, nullptr);
		err[n_read] = '\0';

		// TODO: multiple lines, !file
		error = "";
		output_stderr = err;

		CloseHandle(info.hProcess);
		CloseHandle(stderr_write);
		CloseHandle(stderr_read);
		// It's just warnings if nasm has managed to generate the output
		return std::filesystem::exists(output_filename);
	}

	CloseHandle(info.hProcess);
	CloseHandle(stderr_write);
	CloseHandle(stderr_read);
	return true;
}